"""
News Callbacks Manager - Gestionnaire centralis√© des callbacks news
Regroupe tous les callbacks li√©s aux news (√©conomiques et crypto)
"""

import logging
from typing import Any, Dict, List, Optional
from datetime import datetime

import dash_bootstrap_components as dbc
from dash import Input, Output, State, callback, dcc, html
import plotly.graph_objects as go

from ..base.callback_manager import CallbackManager
from ..base.callback_registry import get_callback_registry

logger = logging.getLogger(__name__)


class NewsCallbacks(CallbackManager):
    """
    Gestionnaire centralis√© des callbacks pour les news.
    Regroupe les callbacks de :
    - crypto_news_module.py (5 callbacks)
    - economic_news_module.py (4 callbacks)
    - crypto_news_phase4_extensions.py (3 callbacks)
    """

    def __init__(self, app, crypto_news_module=None, economic_news_module=None):
        """
        Initialise le gestionnaire de callbacks news.

        Args:
            app: Instance de l'application Dash
            crypto_news_module: Instance du module crypto news
            economic_news_module: Instance du module economic news
        """
        super().__init__(app, "NewsCallbacks")
        self.crypto_news_module = crypto_news_module
        self.economic_news_module = economic_news_module
        self.registry = get_callback_registry()

    def register_all_callbacks(self) -> None:
        """Enregistre tous les callbacks news."""
        logger.info("üîÑ Enregistrement des callbacks news...")

        # Callbacks crypto news
        if self.crypto_news_module:
            self._register_crypto_news_callbacks()

        # Callbacks economic news
        if self.economic_news_module:
            self._register_economic_news_callbacks()

        # Callbacks extensions phase 4
        self._register_phase4_callbacks()

        self.log_callback_registration()
        logger.info("‚úÖ Callbacks news enregistr√©s")

    def _register_crypto_news_callbacks(self) -> None:
        """Enregistre les 5 callbacks du module crypto news."""
        app = self.app

        @app.callback(
            [
                Output("crypto-news-store", "data"),
                Output("crypto-sentiment-store", "data"),
            ],
            [
                Input("refresh-crypto-news-btn", "n_clicks"),
                Input("crypto-news-interval", "n_intervals"),
            ],
        )
        def update_crypto_news_data(refresh_clicks, interval_clicks):
            """Mettre √† jour les donn√©es RSS crypto"""
            if not self.crypto_news_module:
                return {}, {}

            # R√©cup√©rer news RSS (retourne une liste d'articles)
            articles = self.crypto_news_module.get_rss_news()

            # Analyser sentiment crypto avec la liste
            sentiment = self.crypto_news_module.analyze_crypto_sentiment(articles)

            # Extraire trending coins avec la liste
            trending = self.crypto_news_module.extract_crypto_trending(articles)

            # Calculer Fear & Greed crypto avec la liste
            fear_greed = self.crypto_news_module.calculate_crypto_fear_greed(articles, sentiment)

            # Analyser impact prix avec la liste
            price_impact = self.crypto_news_module.analyze_price_impact(articles)

            # Format coh√©rent pour tous les widgets
            news_data = {
                "news": articles,  # Liste d'articles pour les widgets
                "trending": trending,
                "fear_greed": fear_greed,
                "price_impact": price_impact,
                "total": len(articles),
                "timestamp": datetime.now().isoformat(),
            }

            self.registry.register_callback(
                "NewsCallbacks", "update_crypto_news_data",
                ["refresh-crypto-news-btn.n_clicks", "crypto-news-interval.n_intervals"],
                ["crypto-news-store.data", "crypto-sentiment-store.data"]
            )

            return news_data, sentiment

        self.register_callback(update_crypto_news_data, "update_crypto_news_data")

        @app.callback(
            Output("crypto-news-feed", "children"),
            [Input("crypto-news-store", "data")]
        )
        def update_crypto_news_feed(news_data):
            """Mettre √† jour le feed de news crypto"""
            if not news_data or not news_data.get("news"):
                return dbc.Alert("Aucune news crypto RSS disponible", color="warning")

            news_items = []
            for article in news_data["news"][:20]:
                # D√©terminer couleur sentiment crypto
                sentiment = article.get("sentiment", "neutral")
                if sentiment in ["positive", "bullish"]:
                    border_color = "border-success"
                elif sentiment in ["negative", "bearish"]:
                    border_color = "border-danger"
                else:
                    border_color = "border-secondary"

                # Cr√©er item news avec sentiment
                news_item = dbc.Card(
                    [
                        dbc.CardHeader(
                            html.A(
                                article.get("title", "Titre indisponible"),
                                href=article.get("link", "#"),
                                target="_blank",
                                className="text-decoration-none",
                            )
                        ),
                        dbc.CardBody(
                            [
                                html.P(
                                    article.get("description", "Description indisponible")[:200] + "...",
                                    className="card-text small",
                                ),
                                html.Small(
                                    f"üìÖ {article.get('published', 'Date inconnue')} | "
                                    f"üîç Source: {article.get('source', 'Inconnue')}",
                                    className="text-muted",
                                ),
                            ]
                        ),
                    ],
                    className=f"mb-3 {border_color}",
                )
                news_items.append(news_item)

            self.registry.register_callback(
                "NewsCallbacks", "update_crypto_news_feed",
                ["crypto-news-store.data"], ["crypto-news-feed.children"]
            )

            return news_items

        self.register_callback(update_crypto_news_feed, "update_crypto_news_feed")

        @app.callback(
            Output("crypto-fear-greed-gauge", "figure"),
            [Input("crypto-news-store", "data")]
        )
        def update_crypto_fear_greed_gauge(news_data):
            """Gauge Fear & Greed crypto bas√© sur l'analyse des vraies news"""
            try:
                # Calcul du score bas√© sur les vraies donn√©es RSS
                if not news_data or not news_data.get("news"):
                    # Valeurs par d√©faut
                    fear_greed_score = 55
                else:
                    # Utiliser les donn√©es calcul√©es du store
                    fear_greed_data = news_data.get("fear_greed", {})
                    fear_greed_score = fear_greed_data.get("score", 55)

                # Cr√©er le gauge
                fig = go.Figure(go.Indicator(
                    mode="gauge+number",
                    value=fear_greed_score,
                    domain={'x': [0, 1], 'y': [0, 1]},
                    title={'text': "Crypto Fear & Greed Index"},
                    gauge={
                        'axis': {'range': [0, 100]},
                        'bar': {'color': "darkblue"},
                        'steps': [
                            {'range': [0, 20], 'color': "darkred"},
                            {'range': [20, 40], 'color': "orange"},
                            {'range': [40, 60], 'color': "yellow"},
                            {'range': [60, 80], 'color': "lightgreen"},
                            {'range': [80, 100], 'color': "green"}
                        ],
                        'threshold': {
                            'line': {'color': "red", 'width': 4},
                            'thickness': 0.75,
                            'value': fear_greed_score
                        }
                    }
                ))

                fig.update_layout(
                    height=200,
                    margin=dict(l=20, r=20, t=40, b=20)
                )

                self.registry.register_callback(
                    "NewsCallbacks", "update_crypto_fear_greed_gauge",
                    ["crypto-news-store.data"], ["crypto-fear-greed-gauge.figure"]
                )

                return fig

            except Exception as e:
                logger.error(f"Erreur gauge Fear & Greed crypto: {e}")
                # Gauge d'erreur
                fig = go.Figure(go.Indicator(
                    mode="gauge+number",
                    value=50,
                    title={'text': "Erreur - Fear & Greed"},
                    gauge={'axis': {'range': [0, 100]}}
                ))
                return fig

        self.register_callback(update_crypto_fear_greed_gauge, "update_crypto_fear_greed_gauge")

        @app.callback(
            Output("crypto-trending-coins", "children"),
            [Input("crypto-news-store", "data")]
        )
        def update_crypto_trending_coins(news_data):
            """Widget coins tendance bas√© sur les mentions dans les news"""
            try:
                if not news_data or not news_data.get("trending"):
                    # Donn√©es de d√©monstration
                    return html.Div([
                        dbc.Row([
                            dbc.Col("BTC", width=4),
                            dbc.Col("$65,432", width=4, className="text-end"),
                            dbc.Col([
                                html.I(className="fas fa-arrow-up text-success")
                            ], width=4, className="text-end"),
                        ], className="mb-2"),
                        dbc.Row([
                            dbc.Col("ETH", width=4),
                            dbc.Col("$3,124", width=4, className="text-end"),
                            dbc.Col([
                                html.I(className="fas fa-arrow-up text-success")
                            ], width=4, className="text-end"),
                        ], className="mb-2"),
                        dbc.Row([
                            dbc.Col("SOL", width=4),
                            dbc.Col("$145", width=4, className="text-end"),
                            dbc.Col([
                                html.I(className="fas fa-arrow-down text-danger")
                            ], width=4, className="text-end"),
                        ])
                    ])

                # Utiliser les donn√©es calcul√©es du store
                trending_coins = news_data.get("trending", [])[:5]

                if not trending_coins:
                    return html.Div("Aucune donn√©e tendance disponible")

                rows = []
                for coin_data in trending_coins:
                    coin = coin_data.get("coin", "N/A")
                    mentions = coin_data.get("mentions", 0)
                    trend = coin_data.get("trend", "stable")
                    sentiment = coin_data.get("sentiment", "neutral")

                    # D√©terminer l'ic√¥ne et la couleur
                    if trend == "up" or sentiment == "positive":
                        icon = html.I(className="fas fa-arrow-up text-success")
                    elif trend == "down" or sentiment == "negative":
                        icon = html.I(className="fas fa-arrow-down text-danger")
                    else:
                        icon = html.I(className="fas fa-minus text-warning")

                    rows.append(
                        dbc.Row([
                            dbc.Col(coin, width=4),
                            dbc.Col(f"{mentions} mentions", width=4, className="text-end"),
                            dbc.Col(icon, width=4, className="text-end"),
                        ], className="mb-2")
                    )

                self.registry.register_callback(
                    "NewsCallbacks", "update_crypto_trending_coins",
                    ["crypto-news-store.data"], ["crypto-trending-coins.children"]
                )

                return html.Div(rows)

            except Exception as e:
                logger.error(f"Erreur widget trending coins: {e}")
                return html.Div("Erreur de chargement des tendances")

        self.register_callback(update_crypto_trending_coins, "update_crypto_trending_coins")

        @app.callback(
            Output("crypto-price-impact-widget", "children"),
            [Input("crypto-news-store", "data")]
        )
        def update_crypto_trends_widget(news_data):
            """Widget tendances crypto bas√© sur l'analyse des news"""
            try:
                if not news_data or not news_data.get("price_impact"):
                    # Tendances g√©n√©riques de d√©monstration
                    return html.Div([
                        html.Div([
                            html.H6("üöÄ DeFi en hausse", className="mb-1"),
                            html.P("Les protocoles d√©centralis√©s attirent plus d'attention",
                                  className="small text-muted"),
                        ], className="mb-3"),
                        html.Div([
                            html.H6("üìà Adoption institutionnelle", className="mb-1"),
                            html.P("Les grandes entreprises s'int√©ressent aux cryptos",
                                  className="small text-muted"),
                        ], className="mb-3"),
                        html.Div([
                            html.H6("‚ö° Layer 2 Solutions", className="mb-1"),
                            html.P("Les solutions de mise √† l'√©chelle gagnent du terrain",
                                  className="small text-muted"),
                        ])
                    ])

                # Utiliser les donn√©es d'impact prix du store
                price_impact = news_data.get("price_impact", {})

                trends = []
                if price_impact.get("high", 0) > 30:
                    trends.append({
                        "icon": "üö®",
                        "title": "Impact √âlev√©",
                        "description": "√âv√©nements majeurs d√©tect√©s (ETF, r√©gulations, etc.)"
                    })
                if price_impact.get("medium", 0) > 40:
                    trends.append({
                        "icon": "üìà",
                        "title": "Momentum Moyen",
                        "description": "Partenariats et annonces importantes"
                    })

                # Ajouter tendances par d√©faut si aucune d√©tect√©e
                if not trends:
                    trends = [
                        {
                            "icon": "üìä",
                            "title": "Analyse en cours",
                            "description": "Analyse des tendances crypto en temps r√©el"
                        }
                    ]

                trend_divs = []
                for trend in trends[:3]:  # Limiter √† 3 tendances
                    trend_divs.append(
                        html.Div([
                            html.H6(f"{trend['icon']} {trend['title']}", className="mb-1"),
                            html.P(trend['description'], className="small text-muted"),
                        ], className="mb-3")
                    )

                self.registry.register_callback(
                    "NewsCallbacks", "update_crypto_trends_widget",
                    ["crypto-news-store.data"], ["crypto-price-impact-widget.children"]
                )

                return html.Div(trend_divs)

            except Exception as e:
                logger.error(f"Erreur widget tendances crypto: {e}")
                return html.Div("Erreur de chargement des tendances")

        self.register_callback(update_crypto_trends_widget, "update_crypto_trends_widget")

        # Continuer avec les autres callbacks crypto...
        # (Migration compl√®te des 5 callbacks crypto)

    def _register_economic_news_callbacks(self) -> None:
        """Enregistre les 4 callbacks du module economic news."""
        # TODO: Impl√©menter quand economic_news_module sera disponible
        pass

    def _register_phase4_callbacks(self) -> None:
        """Enregistre les 3 callbacks des extensions phase 4."""
        # TODO: Impl√©menter quand les extensions seront analys√©es
        pass</content>
<parameter name="filePath">/home/rono/THEBOT/dash_modules/callbacks/managers/news_callbacks.py