#!/usr/bin/env python3
"""
Test des composants Phase 4 - Crypto Avanc√©s
Validation des 3 nouveaux modules crypto
"""

import sys
import os
import traceback
from datetime import datetime

# Ajouter le chemin du projet
sys.path.insert(0, '/home/rono/THEBOT')

def test_crypto_trends():
    """Test du composant crypto trends"""
    print("\nüß™ TEST CRYPTO TRENDS COMPONENT")
    print("=" * 50)
    
    try:
        from dash_modules.components.crypto_trends import crypto_trends
        
        # Test 1: R√©cup√©ration trending coins
        print("üìä Test trending coins...")
        trending = crypto_trends.get_trending_coins(5)
        
        if trending:
            print(f"‚úÖ {len(trending)} cryptos trending r√©cup√©r√©es")
            for i, coin in enumerate(trending[:3], 1):
                print(f"   {i}. {coin['symbol']} - {coin['change_24h']:.2f}% - {coin['momentum']}")
        else:
            print("‚ö†Ô∏è Aucune crypto trending")
        
        # Test 2: Analyse volume
        print("\nüìà Test analyse volume...")
        volume_analysis = crypto_trends.get_volume_analysis()
        
        if volume_analysis:
            print(f"‚úÖ Analyse volume disponible")
            print(f"   Paires actives: {volume_analysis.get('active_pairs', 0)}")
            print(f"   Sentiment march√©: {volume_analysis.get('market_sentiment', 'Unknown')}")
            print(f"   Tendance volume: {volume_analysis.get('volume_trend', 'Unknown')}")
        else:
            print("‚ö†Ô∏è Analyse volume indisponible")
        
        # Test 3: Changements prix
        print("\nüí∞ Test changements prix...")
        price_changes = crypto_trends.get_price_changes()
        
        if price_changes:
            print(f"‚úÖ Analyse changements prix disponible")
            extremes = price_changes.get('extremes', {})
            if extremes.get('biggest_gainer'):
                gainer = extremes['biggest_gainer']
                print(f"   Plus gros gainer: {gainer.get('symbol', 'N/A')} - {gainer.get('priceChangePercent', 0):.2f}%")
        else:
            print("‚ö†Ô∏è Changements prix indisponibles")
        
        # Test 4: Widget creation
        print("\nüé® Test cr√©ation widget...")
        widget = crypto_trends.create_trends_widget()
        print("‚úÖ Widget crypto trends cr√©√©")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur test crypto trends: {e}")
        traceback.print_exc()
        return False

def test_top_performers():
    """Test du composant top performers"""
    print("\nüß™ TEST TOP PERFORMERS COMPONENT")
    print("=" * 50)
    
    try:
        from dash_modules.components.top_performers import top_performers
        
        # Test 1: Top gainers
        print("üèÜ Test top gainers...")
        gainers = top_performers.get_top_gainers(5)
        
        if gainers:
            print(f"‚úÖ {len(gainers)} top gainers r√©cup√©r√©s")
            for i, gainer in enumerate(gainers[:3], 1):
                print(f"   {i}. {gainer['symbol']} - {gainer['change_percent']:.2f}% - {gainer['risk_level']}")
        else:
            print("‚ö†Ô∏è Aucun gainer trouv√©")
        
        # Test 2: Top losers
        print("\nüìâ Test top losers...")
        losers = top_performers.get_top_losers(5)
        
        if losers:
            print(f"‚úÖ {len(losers)} top losers r√©cup√©r√©s")
            for i, loser in enumerate(losers[:3], 1):
                print(f"   {i}. {loser['symbol']} - {loser['change_percent']:.2f}% - {loser['recovery_potential']}")
        else:
            print("‚ö†Ô∏è Aucun loser trouv√©")
        
        # Test 3: Corr√©lations
        print("\nüîó Test corr√©lations...")
        correlations = top_performers.calculate_correlations()
        
        if correlations:
            print("‚úÖ Matrice de corr√©lation calcul√©e")
            matrix = correlations.get('correlation_matrix', {})
            if matrix:
                symbols = list(matrix.keys())[:3]
                print(f"   Symboles analys√©s: {', '.join([s.replace('USDT', '') for s in symbols])}")
        else:
            print("‚ö†Ô∏è Corr√©lations indisponibles")
        
        # Test 4: Ratios performance
        print("\nüìä Test ratios performance...")
        ratios = top_performers.get_performance_ratios()
        
        if ratios:
            print("‚úÖ Ratios de performance calcul√©s")
            print(f"   Condition march√©: {ratios.get('market_condition', 'Unknown')}")
            print(f"   Ratio Bull/Bear: {ratios.get('bull_bear_ratio', 0):.2f}")
            print(f"   Index force: {ratios.get('strength_index', 0):.1f}%")
        else:
            print("‚ö†Ô∏è Ratios indisponibles")
        
        # Test 5: Widget creation
        print("\nüé® Test cr√©ation widget...")
        widget = top_performers.create_performance_widget()
        print("‚úÖ Widget top performers cr√©√©")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur test top performers: {e}")
        traceback.print_exc()
        return False

def test_fear_greed_gauge():
    """Test du composant Fear & Greed Gauge"""
    print("\nüß™ TEST FEAR & GREED GAUGE COMPONENT")
    print("=" * 50)
    
    try:
        from dash_modules.components.fear_greed_gauge import fear_greed_gauge
        
        # Test 1: Index actuel
        print("üò® Test Fear & Greed Index actuel...")
        current_index = fear_greed_gauge.get_fear_greed_index()
        
        if current_index:
            print(f"‚úÖ Index Fear & Greed r√©cup√©r√©")
            print(f"   Valeur: {current_index['value']}/100")
            print(f"   Classification: {current_index['value_classification']}")
            print(f"   Niveau: {current_index['level']}")
            print(f"   Recommandation: {current_index['recommendation'].get('action', 'N/A')}")
        else:
            print("‚ö†Ô∏è Index Fear & Greed indisponible")
        
        # Test 2: Donn√©es historiques
        print("\nüìà Test donn√©es historiques...")
        historical = fear_greed_gauge.get_historical_data(7)
        
        if historical:
            print(f"‚úÖ {len(historical)} entr√©es historiques r√©cup√©r√©es")
            if len(historical) >= 3:
                recent = historical[:3]
                print("   Derni√®res valeurs:")
                for entry in recent:
                    print(f"     {entry['date']}: {entry['value']} ({entry['value_classification']})")
        else:
            print("‚ö†Ô∏è Donn√©es historiques indisponibles")
        
        # Test 3: Analyse tendances
        print("\nüìä Test analyse tendances...")
        if historical:
            trends = fear_greed_gauge.analyze_trends(historical)
            
            if trends:
                print("‚úÖ Analyse des tendances effectu√©e")
                print(f"   Direction: {trends.get('trend_direction', 'Unknown')}")
                print(f"   Force: {trends.get('trend_strength', 0):.1f}")
                print(f"   Signal: {trends.get('signal', {}).get('signal', 'Unknown')}")
            else:
                print("‚ö†Ô∏è Analyse tendances √©chou√©e")
        
        # Test 4: Alertes
        print("\nüö® Test syst√®me d'alertes...")
        if current_index:
            alerts = fear_greed_gauge.setup_alerts(current_index['value'])
            
            if alerts:
                print(f"‚úÖ {len(alerts)} alertes configur√©es")
                for alert in alerts[:2]:  # Afficher 2 premi√®res alertes
                    print(f"   {alert['type']}: {alert['message']}")
            else:
                print("‚úÖ Aucune alerte active (normal)")
        
        # Test 5: Widget creation
        print("\nüé® Test cr√©ation widget...")
        widget = fear_greed_gauge.create_gauge_widget()
        print("‚úÖ Widget Fear & Greed Gauge cr√©√©")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur test Fear & Greed Gauge: {e}")
        traceback.print_exc()
        return False

def test_integration():
    """Test d'int√©gration des composants Phase 4"""
    print("\nüß™ TEST INT√âGRATION PHASE 4")
    print("=" * 50)
    
    try:
        # Test imports simultan√©s
        print("üì¶ Test imports simultan√©s...")
        from dash_modules.components.crypto_trends import crypto_trends
        from dash_modules.components.top_performers import top_performers
        from dash_modules.components.fear_greed_gauge import fear_greed_gauge
        print("‚úÖ Tous les composants import√©s")
        
        # Test donn√©es cross-component
        print("\nüîó Test compatibilit√© donn√©es...")
        
        # R√©cup√©rer donn√©es de chaque composant
        trending_data = crypto_trends.get_trending_coins(3)
        gainers_data = top_performers.get_top_gainers(3)
        fear_data = fear_greed_gauge.get_fear_greed_index()
        
        success_count = 0
        if trending_data:
            success_count += 1
        if gainers_data:
            success_count += 1
        if fear_data:
            success_count += 1
        
        print(f"‚úÖ {success_count}/3 composants fonctionnels")
        
        # Test coh√©rence des donn√©es
        if trending_data and gainers_data:
            trending_symbols = {coin['symbol'] for coin in trending_data}
            gainers_symbols = {coin['symbol'] for coin in gainers_data}
            common_symbols = trending_symbols.intersection(gainers_symbols)
            
            if common_symbols:
                print(f"‚úÖ Symboles communs d√©tect√©s: {len(common_symbols)}")
            else:
                print("‚ÑπÔ∏è Aucun symbole commun (normal selon les crit√®res)")
        
        return success_count >= 2  # Au moins 2 composants doivent fonctionner
        
    except Exception as e:
        print(f"‚ùå Erreur test int√©gration: {e}")
        traceback.print_exc()
        return False

def main():
    """Fonction principale de test"""
    print("üöÄ THEBOT - TEST PHASE 4 : COMPOSANTS CRYPTO AVANC√âS")
    print("=" * 70)
    print(f"‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()
    
    # Tests individuels
    results = []
    
    # Test 1: Crypto Trends
    results.append(test_crypto_trends())
    
    # Test 2: Top Performers
    results.append(test_top_performers())
    
    # Test 3: Fear & Greed Gauge
    results.append(test_fear_greed_gauge())
    
    # Test 4: Int√©gration
    results.append(test_integration())
    
    # R√©sum√© final
    print("\n" + "=" * 70)
    print("üìä R√âSUM√â TESTS PHASE 4")
    print("=" * 70)
    
    test_names = [
        "Crypto Trends Component",
        "Top Performers Component", 
        "Fear & Greed Gauge Component",
        "Integration Test"
    ]
    
    success_count = 0
    for i, (name, result) in enumerate(zip(test_names, results), 1):
        status = "‚úÖ PASS" if result else "‚ùå FAIL"
        print(f"{i}. {name}: {status}")
        if result:
            success_count += 1
    
    # Score final
    total_tests = len(results)
    success_rate = (success_count / total_tests) * 100
    
    print(f"\nüìà SCORE FINAL: {success_count}/{total_tests} ({success_rate:.0f}%)")
    
    if success_rate >= 75:
        print("üéâ PHASE 4 - SUCC√àS! Composants crypto avanc√©s op√©rationnels")
        print("‚úÖ Pr√™t pour int√©gration au dashboard principal")
    elif success_rate >= 50:
        print("‚ö†Ô∏è PHASE 4 - PARTIEL. Quelques ajustements n√©cessaires")
    else:
        print("‚ùå PHASE 4 - √âCHEC. R√©vision majeure requise")
    
    print(f"\nüéØ Phase 4 compl√©t√©e - Dashboard crypto professionnel")
    print(f"üí∞ Co√ªt total maintenu: 0‚Ç¨/mois")
    
    return success_rate >= 75

if __name__ == "__main__":
    main()