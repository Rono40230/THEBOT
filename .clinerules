# THEBOT - R√®gles de d√©veloppement

## ‚ö†Ô∏è IMP√âRATIF - Ne JAMAIS enfreindre

### üéØ R√àGLES DE COMPORTEMENT CRITIQUE

**PROFIL UTILISATEUR : Non-codeur - Claude modifie directement les fichiers dans VSCode**

1. **Structure modulaire OBLIGATOIRE**
   - ‚úÖ TOUTE impl√©mentation DOIT respecter l'architecture modulaire existante
   - ‚úÖ Suivre EXACTEMENT le pattern `[category]/[name]/{__init__.py, config.py, calculator.py, plotter.py}`
   - ‚ùå JAMAIS cr√©er de nouvelle structure sans validation explicite

2. **Ne JAMAIS casser le code existant**
   - ‚úÖ Tester l'impact sur le code existant AVANT toute modification
   - ‚úÖ Si une modification risque de casser quelque chose : DEMANDER confirmation avant d'agir
   - ‚ùå AUCUNE modification du code fonctionnel sans approbation explicite
   - ‚úÖ **AVERTIR** clairement si une modification touche du code sensible

3. **Z√©ro initiative non sollicit√©e**
   - ‚ùå INTERDICTION ABSOLUE de proposer des "am√©liorations" non demand√©es
   - ‚ùå Ne JAMAIS refactoriser sans demande explicite
   - ‚ùå Ne JAMAIS "optimiser" le code sans instruction
   - ‚úÖ Faire UNIQUEMENT ce qui est demand√©, rien de plus
   - ‚úÖ **EXCEPTION** : Signaler bri√®vement les opportunit√©s d'optimisation CRITIQUES (>20% performance) SANS les impl√©menter

4. **Communication adapt√©e aux non-codeurs**
   - ‚úÖ **MODIFICATIONS DIRECTES** : Claude modifie les fichiers directement dans VSCode
   - ‚úÖ **FEEDBACK MINIMAL** : Apr√®s modification r√©ussie, message court type "‚úÖ Modifi√© : [fichier]"
   - ‚úÖ **EXPLICATIONS CIBL√âES** : Expliquer uniquement les d√©cisions importantes ou concepts nouveaux
   - ‚úÖ **OPTIMISATIONS** : Sugg√©rer optimisations si impact significatif (>20%) SANS les appliquer automatiquement
   - ‚ùå **PAS de r√©sum√©** d√©taill√© de ce qui a √©t√© chang√© (l'utilisateur voit les changements dans VSCode)
   - ‚ùå **PAS de jargon** technique non expliqu√©

5. **Gestion des bugs r√©currents**
   - ‚úÖ Apr√®s **5 tentatives √©chou√©es** sur la m√™me correction : CHANGER DE STRAT√âGIE
   - ‚úÖ Reconna√Ætre explicitement : "‚ùå Ma logique est incorrecte, je teste une autre approche"
   - ‚úÖ **EXPLIQUER** bri√®vement pourquoi la nouvelle approche est diff√©rente (2-3 lignes max)
   - ‚úÖ Proposer UNE alternative radicalement diff√©rente
   - ‚ùå Ne JAMAIS r√©p√©ter la m√™me logique en esp√©rant un r√©sultat diff√©rent

6. **√âconomie de tokens intelligente**
   - ‚úÖ Priorit√© tokens pour : MODIFICATIONS CODE + EXPLICATIONS CRITIQUES + OPTIMISATIONS
   - ‚ùå √âviter : Longs r√©sum√©s de modifications, explications √©videntes, th√©orie excessive
   - ‚úÖ Format ultra-concis : l'utilisateur VOIT les changements dans VSCode
   - ‚úÖ Utiliser des emojis (‚úÖ‚ùå‚ö†Ô∏è‚ö°) pour clart√© visuelle rapide

### Format de r√©ponse OBLIGATOIRE

**Pour une modification simple (95% des cas) :**
```
‚úÖ Modifi√© : `src/thebot/indicators/basic/sma/calculator.py`
```

**Pour une modification avec point important :**
```
‚úÖ Modifi√© : `src/thebot/indicators/basic/rsi/calculator.py`

üí° Utilise maintenant Decimal pour √©viter erreurs d'arrondi sur prix.
```

**Pour correction apr√®s erreur :**
```
‚úÖ Corrig√© : `chemin/vers/fichier.py`
```

**Pour bug r√©current (5+ √©checs) :**
```
‚ùå Ma logique pandas.ewm() ne fonctionne pas.
Nouvelle approche : calcul manuel avec numpy (plus stable).

‚úÖ Modifi√© : `src/thebot/indicators/basic/ema/calculator.py`
```

**Pour sugg√©rer optimisation CRITIQUE :**
```
‚ö° OPTIMISATION : Calcul actuel 2.5s ‚Üí possible 0.3s avec vectorisation numpy (gain 88%).

Veux-tu que je l'impl√©mente ?
```

**Pour demander confirmation avant modification sensible :**
```
‚ö†Ô∏è Cette modification va toucher `core/types.py` utilis√© par 15 modules.
Risque de casser le code existant.

Veux-tu que je continue ?
```

### S√©curit√© et donn√©es sensibles
- ‚ùå **Interdiction absolue** : Jamais de cl√©s API, tokens, ou credentials en dur dans le code
- ‚ùå **Interdiction absolue** : Pas de localStorage/sessionStorage dans les artifacts/dashboards
- ‚úÖ **Obligatoire** : Toutes les credentials dans `config/api_keys.env` (non versionn√©)
- ‚úÖ **Obligatoire** : Utiliser des variables d'environnement pour les secrets
- ‚úÖ **Obligatoire** : Valider et nettoyer toutes les entr√©es utilisateur

### Gestion d'erreurs et robustesse
- ‚úÖ **Obligatoire** : G√©rer TOUTES les exceptions avec try/except appropri√©s
- ‚úÖ **Obligatoire** : Logger toutes les erreurs avec contexte d√©taill√©
- ‚úÖ **Obligatoire** : Timeout sur TOUS les appels API externes
- ‚úÖ **Obligatoire** : Retry logic pour les op√©rations critiques (max 3 tentatives)
- ‚úÖ **Obligatoire** : Graceful degradation si service externe indisponible

### Tests et qualit√©
- ‚úÖ **Obligatoire** : Tests unitaires pour CHAQUE nouvel indicateur
- ‚úÖ **Obligatoire** : Coverage > 80% pour le code core
- ‚úÖ **Obligatoire** : Validation des r√©sultats avec pr√©cision Decimal
- ‚úÖ **Obligatoire** : Tests de performance pour indicateurs critiques

---

## üèóÔ∏è Architecture ultra-modulaire (R√àGLE D'OR)

### Pattern pour TOUS les indicateurs
Chaque indicateur DOIT suivre cette structure exacte :

```
src/thebot/indicators/[category]/[name]/
‚îú‚îÄ‚îÄ __init__.py          # Orchestration et API publique
‚îú‚îÄ‚îÄ config.py            # Configuration Pydantic (validation)
‚îú‚îÄ‚îÄ calculator.py        # Logique de calcul pure (Single Responsibility)
‚îî‚îÄ‚îÄ plotter.py           # Visualisation (optionnel)
```

### Principes architecturaux
- **Single Responsibility** : Un module = une responsabilit√© unique
- **Separation of Concerns** : S√©parer config / calcul / visualisation
- **Interface Contracts** : Tous les indicateurs h√©ritent de `base.indicator.Indicator`
- **Dependency Injection** : Pas de d√©pendances hardcod√©es
- **Factory Pattern** : Utiliser `manager.factory` pour cr√©er les indicateurs

### Categories d'indicateurs
- `basic/` : SMA, EMA, ATR, RSI, OBV, SuperTrend
- `momentum/` : Squeeze, Patterns, Breakout
- `structural/` : FVG, Support/Resistance, Fibonacci, Order Blocks
- `smart_money/` : Market Structure, Liquidity, Sessions
- `volume/` : Volume Profile
- `analysis/` : TrendScore, Regime, MTF

---

## üíª Style de code Python

### Versions et compatibilit√©
- **Python** : 3.11+ minimum (utiliser les features modernes)
- **Type hints** : Obligatoires pour TOUTES les fonctions publiques
- **Async** : Utiliser `async/await` pour toutes les op√©rations I/O

### Conventions de nommage
- **Variables** : `snake_case` (ex: `close_prices`, `indicator_values`)
- **Fonctions** : `snake_case` (ex: `calculate_sma`, `fetch_market_data`)
- **Classes** : `PascalCase` (ex: `SimpleMovingAverage`, `DataProvider`)
- **Constantes** : `UPPER_SNAKE_CASE` (ex: `MAX_RETRIES`, `DEFAULT_PERIOD`)
- **Fichiers** : `snake_case.py` (ex: `market_data_repo.py`)
- **Modules priv√©s** : Pr√©fixer avec `_` (ex: `_internal_utils.py`)

### Formatage
- **Formatter** : Black avec line length = 88
- **Import order** : isort avec groupes (stdlib, third-party, local)
- **Docstrings** : Google style pour toutes les classes/fonctions publiques
- **Comments** : En fran√ßais, uniquement pour logique complexe

### Type hints exemples
```python
from typing import Optional, List, Dict, Tuple
from decimal import Decimal
import pandas as pd

def calculate_indicator(
    data: pd.DataFrame,
    period: int = 14,
    source: str = "close"
) -> pd.Series:
    """Calcule un indicateur technique.
    
    Args:
        data: DataFrame avec colonnes OHLCV
        period: P√©riode de calcul (d√©faut: 14)
        source: Colonne √† utiliser (d√©faut: "close")
        
    Returns:
        Series avec valeurs de l'indicateur
        
    Raises:
        ValueError: Si period <= 0 ou source invalide
    """
    ...
```

---

## üìä Donn√©es et pr√©cision

### Types de donn√©es
- **Prix/volumes** : Utiliser `Decimal` pour pr√©cision (jamais float pour prix)
- **Calculs interm√©diaires** : `numpy.float64` acceptable
- **R√©sultats finaux** : Convertir en `Decimal` si n√©cessaire
- **Timestamps** : `pd.Timestamp` avec timezone UTC

### Validation des donn√©es
```python
# Toujours valider les DataFrames en entr√©e
assert isinstance(data, pd.DataFrame), "data doit √™tre un DataFrame"
assert not data.empty, "data ne peut pas √™tre vide"
assert all(col in data.columns for col in ["open", "high", "low", "close"]), \
    "Colonnes OHLC manquantes"
```

### Gestion des NaN
- **Explicite** : Toujours sp√©cifier comment g√©rer les NaN (dropna, fillna, interpolate)
- **Documentation** : Documenter le comportement avec NaN dans docstring
- **Validation** : V√©rifier absence de NaN inattendus dans r√©sultats

---

## üîå APIs et int√©grations

### Structure providers
Chaque provider suit ce pattern :
```python
from abc import ABC, abstractmethod

class BaseProvider(ABC):
    @abstractmethod
    async def fetch_data(self, symbol: str, timeframe: str) -> pd.DataFrame:
        """R√©cup√®re les donn√©es de march√©."""
        pass
    
    @abstractmethod
    async def validate_connection(self) -> bool:
        """V√©rifie la connexion au service."""
        pass
```

### R√®gles pour APIs externes
- **Rate limiting** : Respecter STRICTEMENT les limites (Binance: 1200/min, AlphaVantage: 5/min)
- **Caching** : Toujours cacher les donn√©es pour minimiser les appels
- **Exponential backoff** : Pour les retry apr√®s erreurs
- **Timeout** : 30s pour REST, 60s pour WebSocket
- **Error handling** : G√©rer sp√©cifiquement les erreurs r√©seau vs erreurs API

### APIs utilis√©es
- **Binance** : Crypto (REST + WebSocket)
- **Alpha Vantage** : Forex (REST seulement, limite 5 calls/min)
- **Trading Economics** : Calendrier √©conomique
- **FRED** : Donn√©es macro√©conomiques
- **OpenAI/Claude** : Analyse IA (optionnel)

---

## üóÑÔ∏è Base de donn√©es SQLite

### Mod√®les SQLAlchemy
```python
from sqlalchemy import Column, Integer, String, DateTime, Numeric
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class MarketData(Base):
    __tablename__ = "market_data"
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String, nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    open = Column(Numeric(precision=20, scale=8), nullable=False)
    high = Column(Numeric(precision=20, scale=8), nullable=False)
    low = Column(Numeric(precision=20, scale=8), nullable=False)
    close = Column(Numeric(precision=20, scale=8), nullable=False)
    volume = Column(Numeric(precision=20, scale=8), nullable=False)
```

### Pattern Repository
- Utiliser le pattern Repository pour TOUTE interaction DB
- Un repository par table principale
- M√©thodes async pour op√©rations I/O

### Migrations
- Versioning strict : `v001_description.py`, `v002_description.py`
- Toujours tester rollback
- Documenter les changements dans docstring

---

## üìà Indicateurs techniques

### Validation Pydantic
Tous les configs d'indicateurs utilisent Pydantic :
```python
from pydantic import BaseModel, Field, validator

class SMAConfig(BaseModel):
    period: int = Field(default=20, ge=1, le=500)
    source: str = Field(default="close")
    
    @validator("source")
    def validate_source(cls, v):
        valid_sources = ["open", "high", "low", "close"]
        if v not in valid_sources:
            raise ValueError(f"source doit √™tre parmi {valid_sources}")
        return v
```

### Tests d'indicateurs
Chaque indicateur DOIT avoir :
- Tests avec donn√©es synth√©tiques (edge cases)
- Tests avec donn√©es r√©elles (validation pr√©cision)
- Tests de performance (temps d'ex√©cution)
- Comparaison avec librairie de r√©f√©rence si possible

### Translation depuis Rust (NonoBot)
- Pr√©server EXACTEMENT la logique de calcul
- Adapter les types de donn√©es (Rust ‚Üí Python)
- Maintenir la m√™me pr√©cision num√©rique
- Tester la parit√© des r√©sultats

---

## üß† Intelligence Artificielle

### APIs IA (OpenAI/Claude)
```python
# Pattern pour prompts
MARKET_ANALYSIS_PROMPT = """
Analyse le march√© {symbol} avec les donn√©es suivantes :
- Prix actuel : {price}
- RSI : {rsi}
- Tendance : {trend}

Fournis une analyse concise en 3 points max.
"""

# Toujours g√©rer les erreurs API
try:
    response = await openai_client.analyze(prompt)
except OpenAIError as e:
    logger.error(f"Erreur OpenAI: {e}")
    return "Analyse indisponible"
```

### Machine Learning
- **Librairies** : scikit-learn, tensorflow/pytorch
- **Versioning** : Sauvegarder les mod√®les avec versioning (mlflow ou custom)
- **Features** : Documenter TOUTES les features utilis√©es
- **Validation** : Cross-validation temporelle (pas k-fold classique)
- **Overfitting** : Walk-forward analysis obligatoire

---

## üìä Interface Dash et visualisations

### Structure Dash
```python
import dash
from dash import html, dcc, Input, Output
import plotly.graph_objects as go

app = dash.Dash(__name__)

# Layout modulaire
app.layout = html.Div([
    dcc.Graph(id='price-chart'),
    dcc.Interval(id='interval', interval=1000)  # Update 1s
])

# Callbacks avec error handling
@app.callback(
    Output('price-chart', 'figure'),
    Input('interval', 'n_intervals')
)
def update_chart(n):
    try:
        # Logique de mise √† jour
        return create_figure()
    except Exception as e:
        logger.error(f"Erreur update chart: {e}")
        return go.Figure()  # Figure vide
```

### R√®gles Plotly
- **Th√®me** : Utiliser th√®me sombre par d√©faut (`template="plotly_dark"`)
- **Performance** : Limiter les donn√©es affich√©es (max 1000 points)
- **Responsive** : `config={'responsive': True}`
- **Subplots** : Utiliser `make_subplots` pour indicateurs multiples

---

## üß™ Tests et qualit√©

### Structure des tests
```
tests/
‚îú‚îÄ‚îÄ unit/                    # Tests unitaires isol√©s
‚îÇ   ‚îú‚îÄ‚îÄ test_indicators/
‚îÇ   ‚îî‚îÄ‚îÄ test_data/
‚îú‚îÄ‚îÄ integration/             # Tests int√©gration
‚îÇ   ‚îî‚îÄ‚îÄ test_api_integration.py
‚îî‚îÄ‚îÄ performance/             # Tests performance
    ‚îî‚îÄ‚îÄ test_indicators_speed.py
```

### Pytest conventions
```python
import pytest
import pandas as pd
from decimal import Decimal

@pytest.fixture
def sample_ohlcv_data():
    """Fixture avec donn√©es OHLCV sample."""
    return pd.DataFrame({
        'open': [100, 101, 102],
        'high': [105, 106, 107],
        'low': [99, 100, 101],
        'close': [104, 105, 106],
        'volume': [1000, 1100, 1200]
    })

def test_sma_calculation(sample_ohlcv_data):
    """Test calcul SMA avec donn√©es sample."""
    result = calculate_sma(sample_ohlcv_data, period=2)
    
    assert not result.isna().all(), "SMA ne doit pas √™tre que NaN"
    assert len(result) == len(sample_ohlcv_data), "Longueur doit √™tre pr√©serv√©e"
```

### Coverage
- **Minimum** : 80% pour code core
- **Priorit√©** : 100% pour calculs d'indicateurs
- **Commande** : `pytest --cov=src/thebot --cov-report=html`

---

## üìù Logging et debugging

### Configuration logging
```python
import logging
from pathlib import Path

# Setup logger
logger = logging.getLogger("thebot")
logger.setLevel(logging.INFO)

# File handler
log_file = Path("logs/thebot.log")
log_file.parent.mkdir(exist_ok=True)
fh = logging.FileHandler(log_file)
fh.setFormatter(logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
))
logger.addHandler(fh)
```

### Niveaux de log
- **DEBUG** : D√©tails calculs, valeurs interm√©diaires
- **INFO** : Op√©rations importantes (fetch data, calculate indicator)
- **WARNING** : Situations anormales mais g√©rables (retry, cache miss)
- **ERROR** : Erreurs n√©cessitant attention (API failure, DB error)
- **CRITICAL** : Erreurs bloquantes (connexion DB impossible)

### Pas de print()
‚ùå **Interdit** : `print()` dans le code de production
‚úÖ **Utiliser** : `logger.info()`, `logger.debug()`, etc.

---

## üöÄ Performance et optimisation

### R√®gles de performance
- **Vectorisation** : Utiliser numpy/pandas vectoris√© (√©viter les loops Python)
- **Caching** : Cacher les r√©sultats co√ªteux avec `functools.lru_cache`
- **Lazy loading** : Charger les donn√©es seulement si n√©cessaire
- **Memory** : Nettoyer les DataFrames inutilis√©s (`.drop()`, `del`)

### Profiling
```python
import cProfile
import pstats

def profile_function():
    profiler = cProfile.Profile()
    profiler.enable()
    
    # Code √† profiler
    result = expensive_calculation()
    
    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats(10)  # Top 10
```

---

## üì¶ D√©pendances et environnement

### requirements.txt structure
```txt
# Core
pandas==2.1.0
numpy==1.24.0
SQLAlchemy==2.0.0

# APIs
python-binance==1.0.17
alpha-vantage==2.3.1
aiohttp==3.8.5

# Visualization
plotly==5.17.0
dash==2.14.0

# ML
scikit-learn==1.3.0
tensorflow==2.13.0  # Optionnel

# Testing
pytest==7.4.0
pytest-cov==4.1.0
pytest-asyncio==0.21.0

# Dev
black==23.7.0
isort==5.12.0
mypy==1.5.0
pylint==2.17.0
```

### Environnement virtuel
```bash
# Toujours utiliser venv
python -m venv venv
source venv/bin/activate  # Linux/Mac
venv\Scripts\activate     # Windows

# Installer d√©pendances
pip install -r requirements.txt
```

---

## üìö Documentation

### Docstrings Google style
```python
def calculate_rsi(
    data: pd.DataFrame,
    period: int = 14,
    source: str = "close"
) -> pd.Series:
    """Calcule le Relative Strength Index (RSI).
    
    Le RSI est un oscillateur momentum mesurant la vitesse et 
    l'amplitude des mouvements de prix.
    
    Args:
        data: DataFrame avec colonnes OHLCV
        period: P√©riode de calcul (d√©faut: 14)
        source: Colonne √† utiliser pour le calcul (d√©faut: "close")
        
    Returns:
        Series avec valeurs RSI (0-100)
        
    Raises:
        ValueError: Si period <= 0 ou source invalide
        KeyError: Si colonne source manquante dans data
        
    Example:
        >>> df = pd.DataFrame({'close': [100, 102, 98, 105]})
        >>> rsi = calculate_rsi(df, period=14)
        >>> print(rsi)
    
    Note:
        Les premiers `period` valeurs seront NaN.
        Formule standard de Wilder utilis√©e.
    """
    ...
```

### README et docs
- Maintenir le README.md √† jour avec l'avancement
- Documenter les d√©cisions architecturales importantes
- Cr√©er des guides utilisateur si interface complexe

---

## üîÑ Git workflow

### Branches
- `main` : Production stable
- `develop` : D√©veloppement en cours
- `feature/nom-feature` : Nouvelles fonctionnalit√©s
- `fix/nom-bug` : Corrections de bugs

### Commits conventionnels
```
feat: Ajout indicateur SuperTrend
fix: Correction calcul ATR avec NaN
docs: Mise √† jour README avec exemples
test: Ajout tests unitaires RSI
refactor: Restructuration module data providers
perf: Optimisation calcul SMA vectoris√©
```

### Pull Requests
- Description claire de la modification
- Tests passent (CI/CD)
- Coverage maintenu ou am√©lior√©
- Review obligatoire avant merge

---

## üéØ Sp√©cificit√©s THEBOT

### Focus strat√©gies
1. **Scalping** (priorit√©) : Timeframes 1m, 5m, 15m
2. **Day Trading** : Timeframes 1h, 4h
3. **Swing Trading** : Timeframes 1D, 1W
4. **Position Trading** : Timeframes 1M

### March√©s support√©s
- **Crypto** : BTC, ETH, altcoins majeurs (Binance)
- **Forex** : Paires majeures EUR/USD, GBP/USD, USD/JPY, etc. (Alpha Vantage)

### √âv√©nements √©conomiques
- Int√©grer syst√©matiquement le calendrier √©conomique
- Analyser impact annonces vs mouvements prix
- Alertes pr√©/post √©v√©nements importants
- Corr√©lation √©v√©nements ‚Üî volatilit√©

### Translation indicateurs NonoBot (Rust ‚Üí Python)
- **Source** : https://github.com/Rono40230/NonoBot
- **Objectif** : 25 indicateurs √† traduire
- **M√©thode** : Analyse algorithme Rust ‚Üí Implementation Python pure
- **Validation** : Tester parit√© r√©sultats Rust vs Python
- **Documentation** : R√©f√©rencer l'indicateur Rust source

---

## ‚úÖ Checklist avant chaque commit

- [ ] Code format√© avec Black
- [ ] Imports tri√©s avec isort
- [ ] Type hints pr√©sents
- [ ] Docstrings Google style
- [ ] Tests unitaires passent
- [ ] Coverage maintenu/am√©lior√©
- [ ] Pas de print() en production
- [ ] Pas de credentials en dur
- [ ] Logs appropri√©s ajout√©s
- [ ] Documentation mise √† jour si n√©cessaire
- [ ] **V√âRIFI√â : Aucun code existant cass√©**
- [ ] **V√âRIFI√â : Structure modulaire respect√©e**

---

## üìã Rappel TOKENS - √âconomie INTELLIGENTE pour non-codeur

### Ce qui CONSOMME les tokens (√† utiliser)
‚úÖ Code complet et fonctionnel
‚úÖ Instructions claires (chemins fichiers, commandes)
‚úÖ Explications pour comprendre la logique (si n√©cessaire)
‚úÖ Suggestions d'optimisation critiques (>20% impact)
‚úÖ Aide au debugging avec strat√©gies alternatives

### Ce qui GASPILLE les tokens (√† √©viter)
‚ùå Longs paragraphes d'introduction
‚ùå Historiques d√©taill√©s des modifications
‚ùå Th√©orie excessive sur les concepts
‚ùå Explications de ce qui est √©vident
‚ùå Comptes-rendus verbeux apr√®s succ√®s

### Exemples de r√©ponses adapt√©es

**‚ùå MAUVAIS (trop verbeux pour non-codeur)** :
```
[CODE sans contexte]
```
*Probl√®me : Non-codeur ne sait pas o√π mettre ce code*

**‚ùå MAUVAIS (trop de blabla)** :
```
J'ai analys√© en profondeur votre demande et apr√®s avoir examin√© 
l'architecture existante, j'ai identifi√© que la meilleure approche 
serait d'utiliser le pattern Factory combin√© avec... [500 mots]

Voici le code :
[code]
```
*Probl√®me : Gaspillage de tokens, l'utilisateur veut le code*

**‚úÖ BON (√©quilibre optimal)** :
```
üìÅ Cr√©er : `src/thebot/indicators/basic/rsi/calculator.py`

[CODE COMPLET]

üí° Ce fichier calcule le RSI. Utilise la formule de Wilder.

‚ñ∂Ô∏è Pour tester : `pytest tests/unit/test_indicators/test_rsi.py`
```
*Parfait : Code + Contexte minimal + Action claire*

**‚úÖ BON (optimisation critique)** :
```
‚ö° OPTIMISATION : Calcul actuel prend 2.5s sur 10k bougies
Possible de r√©duire √† 0.3s avec vectorisation numpy.

Veux-tu que je l'impl√©mente ?
```
*Parfait : Impact chiffr√© + Question claire*

**‚úÖ BON (apr√®s 5 √©checs)** :
```
‚ùå Mon approche avec pandas.ewm() ne fonctionne pas.

Nouvelle strat√©gie : Calcul manuel avec boucle numpy (plus lent mais stable).

üìÅ Fichier : `src/thebot/indicators/basic/ema/calculator.py`
[CODE avec nouvelle approche]
```
*Parfait : Reconnaissance erreur + Explication courte + Code*

---

## üö´ Interdictions strictes

### √Ä ne JAMAIS faire
- ‚ùå Credentials/API keys en dur dans le code
- ‚ùå `print()` √† la place de `logger`
- ‚ùå Float pour calculs de prix (utiliser Decimal)
- ‚ùå Ignorer les exceptions (`except: pass`)
- ‚ùå Code non test√© en production
- ‚ùå Boucles Python sur DataFrames (vectoriser)
- ‚ùå Importer tout un module (`from module import *`)
- ‚ùå Variables globales mutables
- ‚ùå Modification des DataFrames en place sans `.copy()`
- ‚ùå Commits sans message clair

---

## üí° Bonnes pratiques encourag√©es

### √Ä privil√©gier
- ‚úÖ Type hints partout
- ‚úÖ Validation Pydantic pour configs
- ‚úÖ Async/await pour I/O
- ‚úÖ Pattern Repository pour DB
- ‚úÖ Factory Pattern pour indicateurs
- ‚úÖ Caching intelligent
- ‚úÖ Logging exhaustif
- ‚úÖ Tests automatis√©s
- ‚úÖ Documentation claire
- ‚úÖ Code review syst√©matique

---

## üéì Ressources et r√©f√©rences

### Documentation officielle
- [Pandas](https://pandas.pydata.org/docs/)
- [NumPy](https://numpy.org/doc/)
- [Plotly](https://plotly.com/python/)
- [Dash](https://dash.plotly.com/)
- [SQLAlchemy](https://docs.sqlalchemy.org/)
- [Pydantic](https://docs.pydantic.dev/)

### APIs
- [Binance API](https://binance-docs.github.io/apidocs/)
- [Alpha Vantage](https://www.alphavantage.co/documentation/)
- [Trading Economics](https://docs.tradingeconomics.com/)
- [FRED API](https://fred.stlouisfed.org/docs/api/fred/)

### Indicateurs techniques
- [Investopedia](https://www.investopedia.com/terms/t/technicalindicator.asp)
- [TradingView Pine Script](https://www.tradingview.com/pine-script-docs/)

---

## üéØ Rappels importants pour Claude

1. **Modularit√©** : Respecter STRICTEMENT l'architecture modulaire des indicateurs
2. **Pr√©cision** : Utiliser Decimal pour prix, valider avec 15+ tests par indicateur
3. **Performance** : Vectoriser avec numpy/pandas, pas de loops Python
4. **Robustesse** : G√©rer TOUTES les erreurs, timeout sur APIs, retry logic
5. **Documentation** : Docstrings Google style, type hints obligatoires
6. **Tests** : Coverage > 80%, tests unitaires pour chaque indicateur
7. **S√©curit√©** : Jamais de credentials en dur, validation inputs
8. **Async** : Utiliser async/await pour toutes op√©rations I/O
9. **Logging** : Logger.info/debug/error, jamais print()
10. **Git** : Commits conventionnels, branches feature/fix

---

**Version** : 1.0
**Derni√®re mise √† jour** : Projet analys√© depuis GitHub
**Auteur** : Documentation g√©n√©r√©e pour THEBOT trading bot